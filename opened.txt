class openedHash {
    struct Node
    {
        Node* next;
        char name[10];

        // присваивание имени name
        Node(char name[10])


        // равны ли имена this и second?
        friend bool operator==(Node* first, char second[10])
            // идем по отдельным символам и сравниваем
    };

private:
    Node array[10];

private:
    // хэш-функция, возвращающая номер элемента массива, в котором находится имя
    int hash(const char name[10]);
        // считает сумму кодов букв в имени и делит на 10


    // поиск имени в списке с head
    // если найдено – возврат prev
    // если не найдено – возврат nullptr
    // для первого элемента списка коллизий – возвращаем его же
    Node* findName(char name[10], Node* head);
        // идем whileом пока не упремся в nullptr
        // храним prev все это время – и если нашли совпадение с cur, возвращаем prev
        // иначе возвращаем nullptr


    void destructor();

public:
    openedHash();

    ~openedHash();

    // вставка имени в словарь
    void insert(char name[10]);
        // вычисляем в хэш-функции номер элемента массива
        // если этот элемент пустой – создаем и заполняем
        // иначе проверяем в findName (может уже есть это имя в списке)
            // если из findName вернулся nullptr – нужно вставить
            // вставляем после "головы"


    // удаление имени из словаря
    void deletE(char name[10]);
        // вычисляем в хэш-функции номер элемента массива
        // если этот элемент пустой – return
        // проверяем в findName есть ли вообще имя в списке и если есть:
            // и это первый элемент
                // и он единственный – делаем nullptr
                // иначе просто все сдвигаем
            // иначе "вырезаем" элемент из списка


    // есть ли имя в словаре?
    bool member(char name[10]);
        // вычисляем в хэш-функции номер элемента массива
        // если этот элемент пустой – return false
        // возвращаем findName()


    void makeNull();